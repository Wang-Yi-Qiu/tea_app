# 微信支付云函数幂等性处理最佳实践

## 概述

微信支付回调通知的幂等性处理是电商平台的核心技术要求，确保在高并发、网络重试等场景下，订单状态的一致性和数据完整性。

## 1. 微信支付回调通知的幂等性处理机制

### 1.1 核心设计原则

**幂等性保证**：
- 同一支付通知重复处理不会产生副作用
- 订单状态转换的原子性
- 业务逻辑与通知机制解耦

**处理流程设计**：
```
微信支付回调 -> 云函数接收 -> 幂等性验证 -> 订单状态更新 -> 业务处理 -> 响应确认
```

### 1.2 基础幂等性处理实现

```javascript
// cloudfunctions/wx-payment-callback/index.js
const cloud = require("wx-server-sdk");
const crypto = require('crypto');

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV,
});

const db = cloud.database();

/**
 * 微信支付回调处理主函数
 * 实现完整的幂等性控制机制
 */
exports.main = async (event, context) => {
  try {
    // 1. 验证请求签名
    const isValidSignature = await verifyPaymentSignature(event);
    if (!isValidSignature) {
      return { code: 'FAIL', message: '签名验证失败' };
    }

    // 2. 解析微信支付通知数据
    const paymentData = parsePaymentNotification(event);

    // 3. 幂等性检查 - 核心逻辑
    const idempotencyResult = await checkIdempotency(paymentData);
    if (idempotencyResult.isDuplicate) {
      console.log('检测到重复支付通知，返回成功响应');
      return { code: 'SUCCESS', message: '处理成功' };
    }

    // 4. 订单状态处理
    const orderProcessResult = await processOrderPayment(paymentData);

    // 5. 记录幂等性处理日志
    await logIdempotencyProcessing(paymentData, orderProcessResult);

    return { code: 'SUCCESS', message: '处理成功' };

  } catch (error) {
    console.error('支付回调处理失败:', error);
    await logErrorToSystem(error, event);

    // 错误情况下返回失败，让微信支付重试
    return { code: 'FAIL', message: '处理失败' };
  }
};

/**
 * 幂等性检查 - 防止重复处理
 * @param {Object} paymentData - 支付数据
 * @returns {Object} 幂等性检查结果
 */
async function checkIdempotency(paymentData) {
  const { out_trade_no, transaction_id } = paymentData;

  try {
    // 检查方法1: 查询订单交易记录表
    const existingTransaction = await db.collection('payment_transactions')
      .where({
        out_trade_no: out_trade_no,
        transaction_id: transaction_id,
        status: 'processed'
      })
      .get();

    if (existingTransaction.data.length > 0) {
      return {
        isDuplicate: true,
        existingRecord: existingTransaction.data[0],
        reason: 'transaction_already_processed'
      };
    }

    // 检查方法2: Redis分布式锁 (如果可用)
    const lockResult = await acquireDistributedLock(`payment_lock_${out_trade_no}`, 30);
    if (!lockResult.success) {
      return {
        isDuplicate: true,
        reason: 'concurrent_processing'
      };
    }

    return {
      isDuplicate: false,
      lockKey: lockResult.lockKey
    };

  } catch (error) {
    console.error('幂等性检查失败:', error);
    // 检查失败时默认允许处理，让业务逻辑二次验证
    return { isDuplicate: false };
  }
}

/**
 * 分布式锁实现 - 防止并发处理
 * @param {string} lockKey - 锁的key
 * @param {number} ttl - 锁的过期时间(秒)
 * @returns {Object} 锁获取结果
 */
async function acquireDistributedLock(lockKey, ttl = 30) {
  try {
    // 方案1: 使用数据库模拟分布式锁
    const lockRecord = {
      lock_key: lockKey,
      lock_value: generateUniqueId(),
      created_time: new Date(),
      expires_time: new Date(Date.now() + ttl * 1000),
      status: 'active'
    };

    // 原子性插入锁记录
    await db.collection('distributed_locks').add({
      data: lockRecord
    });

    return {
      success: true,
      lockKey: lockKey,
      lockValue: lockRecord.lock_value
    };

  } catch (error) {
    // 插入失败可能表示锁已存在
    return { success: false, reason: 'lock_acquisition_failed' };
  }
}

/**
 * 释放分布式锁
 */
async function releaseDistributedLock(lockKey, lockValue) {
  try {
    await db.collection('distributed_locks')
      .where({
        lock_key: lockKey,
        lock_value: lockValue,
        status: 'active'
      })
      .remove();

    return true;
  } catch (error) {
    console.error('释放分布式锁失败:', error);
    return false;
  }
}
```

## 2. 防止重复支付和重复订单状态更新

### 2.1 订单状态机设计

```javascript
/**
 * 订单状态机 - 确保状态转换的幂等性
 */
const ORDER_STATUS = {
  PENDING: 'pending',           // 待支付
  PAID: 'paid',                // 已支付
  PROCESSING: 'processing',     // 处理中
  SHIPPED: 'shipped',           // 已发货
  COMPLETED: 'completed',       // 已完成
  CANCELLED: 'cancelled',       // 已取消
  REFUNDED: 'refunded'          // 已退款
};

/**
 * 状态转换规则 - 定义允许的状态转换
 */
const STATUS_TRANSITIONS = {
  [ORDER_STATUS.PENDING]: [ORDER_STATUS.PAID, ORDER_STATUS.CANCELLED],
  [ORDER_STATUS.PAID]: [ORDER_STATUS.PROCESSING, ORDER_STATUS.CANCELLED],
  [ORDER_STATUS.PROCESSING]: [ORDER_STATUS.SHIPPED, ORDER_STATUS.CANCELLED],
  [ORDER_STATUS.SHIPPED]: [ORDER_STATUS.COMPLETED],
  [ORDER_STATUS.COMPLETED]: [],
  [ORDER_STATUS.CANCELLED]: [],
  [ORDER_STATUS.REFUNDED]: []
};

/**
 * 订单状态更新 - 原子性操作
 * @param {string} orderId - 订单ID
 * @param {string} newStatus - 新状态
 * @param {Object} paymentData - 支付数据
 * @returns {Object} 处理结果
 */
async function updateOrderStatus(orderId, newStatus, paymentData) {
  try {
    // 1. 获取当前订单状态
    const orderRecord = await db.collection('orders')
      .where({
        _id: orderId
      })
      .get();

    if (orderRecord.data.length === 0) {
      throw new Error(`订单不存在: ${orderId}`);
    }

    const currentOrder = orderRecord.data[0];
    const currentStatus = currentOrder.status;

    // 2. 验证状态转换的合法性
    if (!isValidStatusTransition(currentStatus, newStatus)) {
      console.warn(`非法的状态转换: ${currentStatus} -> ${newStatus}`);
      return {
        success: false,
        reason: 'invalid_status_transition',
        currentStatus,
        attemptedStatus: newStatus
      };
    }

    // 3. 检查是否已经是目标状态 (幂等性检查)
    if (currentStatus === newStatus) {
      console.log(`订单已经是目标状态: ${newStatus}`);
      return {
        success: true,
        reason: 'already_in_target_status',
        orderId,
        status: newStatus
      };
    }

    // 4. 原子性更新订单状态
    const updateResult = await db.collection('orders')
      .where({
        _id: orderId,
        status: currentStatus  // 条件更新，防止并发修改
      })
      .update({
        data: {
          status: newStatus,
          updated_time: new Date(),
          payment_info: {
            transaction_id: paymentData.transaction_id,
            paid_time: paymentData.time_end,
            total_fee: paymentData.total_fee
          }
        }
      });

    if (updateResult.stats.updated === 0) {
      // 更新失败，可能是并发修改
      throw new Error('订单状态更新失败，可能存在并发修改');
    }

    // 5. 记录状态变更历史
    await recordOrderStatusHistory(orderId, currentStatus, newStatus, paymentData);

    // 6. 触发后续业务流程
    await triggerBusinessProcess(orderId, newStatus, currentOrder);

    return {
      success: true,
      orderId,
      previousStatus: currentStatus,
      newStatus: newStatus,
      reason: 'status_updated_successfully'
    };

  } catch (error) {
    console.error('订单状态更新失败:', error);
    return {
      success: false,
      reason: 'update_failed',
      error: error.message
    };
  }
}

/**
 * 验证状态转换是否合法
 */
function isValidStatusTransition(currentStatus, newStatus) {
  const allowedTransitions = STATUS_TRANSITIONS[currentStatus] || [];
  return allowedTransitions.includes(newStatus);
}
```

### 2.2 库存管理和原子性操作

```javascript
/**
 * 库存扣减 - 原子性操作防止超卖
 * @param {Array} orderItems - 订单商品列表
 * @param {string} orderId - 订单ID
 * @returns {Object} 处理结果
 */
async function deductInventoryAtomic(orderItems, orderId) {
  const inventoryUpdates = [];

  try {
    // 1. 批量获取库存信息
    const productIds = orderItems.map(item => item.sku_id);
    const inventoryRecords = await db.collection('inventory')
      .where({
        sku_id: db.command.in(productIds)
      })
      .get();

    // 2. 检查库存充足性
    const inventoryMap = {};
    inventoryRecords.data.forEach(record => {
      inventoryMap[record.sku_id] = record;
    });

    for (const item of orderItems) {
      const inventory = inventoryMap[item.sku_id];
      if (!inventory) {
        throw new Error(`SKU库存不存在: ${item.sku_id}`);
      }

      if (inventory.available_quantity < item.quantity) {
        throw new Error(`SKU库存不足: ${item.sku_id}, 需要: ${item.quantity}, 可用: ${inventory.available_quantity}`);
      }
    }

    // 3. 原子性扣减库存
    for (const item of orderItems) {
      const inventory = inventoryMap[item.sku_id];

      const updateResult = await db.collection('inventory')
        .where({
          sku_id: item.sku_id,
          available_quantity: db.command.gte(item.quantity)  // 条件更新
        })
        .update({
          data: {
            available_quantity: db.command.inc(-item.quantity),
            reserved_quantity: db.command.inc(item.quantity),  // 预留库存
            updated_time: new Date(),
            last_order_id: orderId
          }
        });

      if (updateResult.stats.updated === 0) {
        throw new Error(`库存扣减失败: ${item.sku_id}`);
      }

      inventoryUpdates.push({
        sku_id: item.sku_id,
        deducted_quantity: item.quantity,
        remaining_quantity: inventory.available_quantity - item.quantity
      });
    }

    return {
      success: true,
      inventoryUpdates
    };

  } catch (error) {
    // 4. 失败时回滚已扣减的库存
    if (inventoryUpdates.length > 0) {
      await rollbackInventoryDeduction(inventoryUpdates, orderId);
    }

    throw error;
  }
}

/**
 * 库存扣减回滚
 */
async function rollbackInventoryDeduction(inventoryUpdates, orderId) {
  console.log(`开始回滚库存扣减，订单: ${orderId}`);

  for (const update of inventoryUpdates) {
    try {
      await db.collection('inventory')
        .where({
          sku_id: update.sku_id,
          last_order_id: orderId
        })
        .update({
          data: {
            available_quantity: db.command.inc(update.deducted_quantity),
            reserved_quantity: db.command.inc(-update.deducted_quantity),
            updated_time: new Date(),
            last_order_id: null
          }
        });
    } catch (error) {
      console.error(`库存回滚失败: ${update.sku_id}`, error);
    }
  }
}
```

## 3. 微信支付API中的幂等性设计模式

### 3.1 支付订单创建的幂等性

```javascript
/**
 * 创建支付订单 - 幂等性设计
 * @param {Object} orderData - 订单数据
 * @param {Object} userInfo - 用户信息
 * @returns {Object} 支付订单创建结果
 */
async function createPaymentOrder(orderData, userInfo) {
  try {
    // 1. 生成唯一订单号 - 包含时间戳和随机数
    const outTradeNo = generateUniqueOrderNumber(userInfo.openid);

    // 2. 检查是否存在相同请求的订单（重复提交防护）
    const duplicateOrder = await checkDuplicateOrderCreation(userInfo.openid, orderData);
    if (duplicateOrder.exists) {
      return {
        success: true,
        orderId: duplicateOrder.order._id,
        outTradeNo: duplicateOrder.order.out_trade_no,
        reason: 'order_already_exists'
      };
    }

    // 3. 创建订单记录
    const orderRecord = {
      out_trade_no: outTradeNo,
      openid: userInfo.openid,
      order_items: orderData.order_items,
      total_amount: orderData.total_amount,
      status: ORDER_STATUS.PENDING,
      created_time: new Date(),
      updated_time: new Date(),
      expire_time: new Date(Date.now() + 30 * 60 * 1000), // 30分钟过期
      payment_status: 'unpaid'
    };

    const orderResult = await db.collection('orders').add({
      data: orderRecord
    });

    // 4. 预扣库存
    await deductInventoryAtomic(orderData.order_items, orderResult._id);

    // 5. 调用微信支付统一下单API
    const wxPayParams = await createWxPaymentOrder(outTradeNo, orderData);

    // 6. 更新订单支付参数
    await db.collection('orders')
      .where({
        _id: orderResult._id
      })
      .update({
        data: {
          wx_pay_params: wxPayParams,
          updated_time: new Date()
        }
      });

    return {
      success: true,
      orderId: orderResult._id,
      outTradeNo: outTradeNo,
      wxPayParams: wxPayParams,
      reason: 'order_created_successfully'
    };

  } catch (error) {
    console.error('创建支付订单失败:', error);
    return {
      success: false,
      reason: 'order_creation_failed',
      error: error.message
    };
  }
}

/**
 * 生成唯一订单号
 * 格式: 时间戳 + 用户标识 + 随机数
 */
function generateUniqueOrderNumber(openid) {
  const timestamp = Date.now();
  const userHash = crypto.createHash('md5').update(openid).digest('hex').substring(0, 8);
  const random = Math.random().toString(36).substring(2, 8);

  return `${timestamp}${userHash}${random}`;
}

/**
 * 检查重复订单创建
 * 基于用户、商品、金额等信息判断是否为重复提交
 */
async function checkDuplicateOrderCreation(openid, orderData) {
  try {
    // 查询最近5分钟内的相同商品组合订单
    const recentTime = new Date(Date.now() - 5 * 60 * 1000);

    const existingOrders = await db.collection('orders')
      .where({
        openid: openid,
        total_amount: orderData.total_amount,
        status: ORDER_STATUS.PENDING,
        created_time: db.command.gte(recentTime)
      })
      .get();

    if (existingOrders.data.length > 0) {
      // 进一步比较商品详情
      for (const existingOrder of existingOrders.data) {
        if (isSameOrderItems(existingOrder.order_items, orderData.order_items)) {
          return {
            exists: true,
            order: existingOrder,
            reason: 'recent_duplicate_order'
          };
        }
      }
    }

    return { exists: false };

  } catch (error) {
    console.error('检查重复订单失败:', error);
    // 检查失败时允许创建，由后续逻辑处理
    return { exists: false };
  }
}

/**
 * 比较订单商品是否相同
 */
function isSameOrderItems(items1, items2) {
  if (items1.length !== items2.length) {
    return false;
  }

  const normalizeItems = (items) => {
    return items.map(item => ({
      sku_id: item.sku_id,
      quantity: item.quantity,
      price: item.price
    })).sort((a, b) => a.sku_id.localeCompare(b.sku_id));
  };

  const normalized1 = normalizeItems(items1);
  const normalized2 = normalizeItems(items2);

  return JSON.stringify(normalized1) === JSON.stringify(normalized2);
}
```

### 3.2 微信支付API调用重试机制

```javascript
/**
 * 微信支付API调用 - 带重试和幂等性
 * @param {string} apiFunction - API函数名
 * @param {Object} params - 调用参数
 * @param {number} maxRetries - 最大重试次数
 * @returns {Object} API调用结果
 */
async function callWxPaymentApiWithRetry(apiFunction, params, maxRetries = 3) {
  let lastError = null;
  const requestId = generateRequestId();

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`微信支付API调用 attempt ${attempt}/${maxRetries}, requestId: ${requestId}`);

      // 记录API调用日志
      await logApiCall(requestId, apiFunction, params, attempt);

      const result = await cloud.openapi.pay[apiFunction](params);

      // 记录成功响应
      await logApiResponse(requestId, result, attempt);

      console.log(`API调用成功: ${requestId}`);
      return {
        success: true,
        data: result,
        requestId: requestId,
        attempt: attempt
      };

    } catch (error) {
      lastError = error;
      console.error(`API调用失败 attempt ${attempt}/${maxRetries}:`, error);

      // 记录错误响应
      await logApiError(requestId, error, attempt);

      // 判断是否需要重试
      if (!shouldRetry(error, attempt, maxRetries)) {
        break;
      }

      // 指数退避重试
      const delayMs = Math.min(1000 * Math.pow(2, attempt - 1), 10000);
      await sleep(delayMs);
    }
  }

  // 所有重试都失败
  console.error(`API调用最终失败: ${requestId}`, lastError);
  throw lastError;
}

/**
 * 判断是否应该重试
 */
function shouldRetry(error, attempt, maxRetries) {
  if (attempt >= maxRetries) {
    return false;
  }

  // 网络相关错误可以重试
  if (error.name === 'NETWORK_ERROR' || error.code === 'NETWORK_ERROR') {
    return true;
  }

  // 微信支付API特定错误码
  const retryableErrorCodes = [
    'SYSTEMERROR',    // 系统错误
    'APPID_NOT_EXIST', // APPID不存在
    'MCHID_NOT_EXIST', // 商户号不存在
    'LACK_PARAMS',    // 缺少参数
    'OUT_TRADE_NO_USED' // 商户订单号重复
  ];

  return retryableErrorCodes.includes(error.code);
}

/**
 * 生成请求ID用于幂等性控制
 */
function generateRequestId() {
  return `req_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
}

/**
 * 睡眠函数
 */
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

## 4. 云函数中处理微信支付回调的最佳实践

### 4.1 完整的支付回调处理流程

```javascript
/**
 * 完整的支付回调处理函数
 * 实现微信支付回调的完整幂等性处理
 */
async function processPaymentCallback(paymentData) {
  const { out_trade_no, transaction_id, result_code } = paymentData;

  try {
    // 1. 记录回调接收
    await recordCallbackReception(paymentData);

    // 2. 验证支付结果
    if (result_code !== 'SUCCESS') {
      console.warn(`支付失败: ${out_trade_no}, 错误码: ${paymentData.err_code}`);
      await handlePaymentFailure(paymentData);
      return { success: true, reason: 'payment_failure_handled' };
    }

    // 3. 幂等性处理锁
    const processingLock = await acquireCallbackProcessingLock(out_trade_no, transaction_id);
    if (!processingLock.success) {
      console.log(`回调正在处理中或已处理: ${out_trade_no}`);
      return { success: true, reason: 'callback_already_processing' };
    }

    try {
      // 4. 查询并验证订单
      const orderRecord = await validateOrderForPayment(out_trade_no);

      // 5. 检查支付状态
      if (orderRecord.payment_status === 'paid') {
        console.log(`订单已支付: ${out_trade_no}`);
        return { success: true, reason: 'order_already_paid' };
      }

      // 6. 记录支付交易
      await recordPaymentTransaction(paymentData, orderRecord._id);

      // 7. 更新订单状态为已支付
      const statusUpdateResult = await updateOrderStatus(
        orderRecord._id,
        ORDER_STATUS.PAID,
        paymentData
      );

      if (!statusUpdateResult.success) {
        throw new Error(`订单状态更新失败: ${statusUpdateResult.reason}`);
      }

      // 8. 触发后续业务流程
      await triggerPostPaymentProcesses(orderRecord, paymentData);

      // 9. 清理处理锁
      await releaseCallbackProcessingLock(processingLock.lockKey);

      console.log(`支付回调处理完成: ${out_trade_no}`);
      return {
        success: true,
        orderId: orderRecord._id,
        reason: 'payment_callback_processed'
      };

    } catch (error) {
      // 10. 错误处理和锁清理
      await releaseCallbackProcessingLock(processingLock.lockKey);
      throw error;
    }

  } catch (error) {
    console.error(`支付回调处理失败: ${out_trade_no}`, error);
    await recordCallbackError(paymentData, error);
    throw error;
  }
}

/**
 * 获取回调处理锁
 */
async function acquireCallbackProcessingLock(outTradeNo, transactionId) {
  const lockKey = `payment_callback_${outTradeNo}_${transactionId}`;

  try {
    const lockData = {
      lock_key: lockKey,
      out_trade_no: outTradeNo,
      transaction_id: transactionId,
      created_time: new Date(),
      expires_time: new Date(Date.now() + 5 * 60 * 1000), // 5分钟过期
      status: 'processing'
    };

    await db.collection('callback_processing_locks').add({
      data: lockData
    });

    return { success: true, lockKey };

  } catch (error) {
    return { success: false, reason: 'lock_acquisition_failed' };
  }
}

/**
 * 触发支付后业务流程
 */
async function triggerPostPaymentProcesses(orderRecord, paymentData) {
  try {
    // 1. 异步发送支付成功通知
    cloud.invokeFunction('send-payment-notification', {
      order_id: orderRecord._id,
      openid: orderRecord.openid,
      payment_data: paymentData
    });

    // 2. 异步更新用户积分
    cloud.invokeFunction('update-user-points', {
      openid: orderRecord.openid,
      order_amount: orderRecord.total_amount,
      order_id: orderRecord._id
    });

    // 3. 异步更新商品销量统计
    cloud.invokeFunction('update-product-sales', {
      order_items: orderRecord.order_items,
      order_id: orderRecord._id
    });

    // 4. 异步生成发货任务
    if (shouldAutoShip(orderRecord)) {
      cloud.invokeFunction('create-shipment-task', {
        order_id: orderRecord._id,
        order_items: orderRecord.order_items
      });
    }

  } catch (error) {
    console.error('触发支付后流程失败:', error);
    // 业务流程失败不影响主流程，记录错误即可
  }
}

/**
 * 判断是否应该自动发货
 */
function shouldAutoShip(orderRecord) {
  // 虚拟商品或数字商品自动发货
  return orderRecord.order_items.every(item =>
    item.category === 'digital' || item.category === 'virtual'
  );
}
```

## 5. 订单号生成和管理策略

### 5.1 订单号生成策略

```javascript
/**
 * 订单号生成器 - 确保唯一性和可追溯性
 */
class OrderNumberGenerator {
  constructor() {
    this.sequenceCache = new Map(); // 内存缓存序列号
  }

  /**
   * 生成订单号
   * @param {string} openid - 用户标识
   * @param {string} channel - 渠道标识
   * @returns {string} 订单号
   */
  async generateOrderNumber(openid, channel = 'default') {
    const today = new Date();
    const datePrefix = this.getDatePrefix(today);
    const channelPrefix = this.getChannelPrefix(channel);

    try {
      // 1. 获取今日序列号
      const sequence = await this.getTodaySequence(datePrefix);

      // 2. 生成用户哈希
      const userHash = this.generateUserHash(openid);

      // 3. 生成校验码
      const checkDigit = this.generateCheckDigit(datePrefix, channelPrefix, sequence, userHash);

      // 4. 组装订单号
      const orderNumber = `${datePrefix}${channelPrefix}${sequence}${userHash}${checkDigit}`;

      console.log(`生成订单号: ${orderNumber} for user: ${openid}`);
      return orderNumber;

    } catch (error) {
      console.error('订单号生成失败:', error);
      // 备用生成策略
      return this.generateFallbackOrderNumber(openid);
    }
  }

  /**
   * 获取日期前缀
   * 格式: YYYYMMDD
   */
  getDatePrefix(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}${month}${day}`;
  }

  /**
   * 获取渠道前缀
   */
  getChannelPrefix(channel) {
    const channelMap = {
      'default': '01',
      'mini-program': '02',
      'h5': '03',
      'app': '04'
    };
    return channelMap[channel] || '01';
  }

  /**
   * 获取今日序列号
   */
  async getTodaySequence(datePrefix) {
    // 检查缓存
    if (this.sequenceCache.has(datePrefix)) {
      return this.sequenceCache.get(datePrefix) + 1;
    }

    try {
      // 从数据库获取最大序列号
      const result = await db.collection('order_sequences')
        .where({
          date_prefix: datePrefix
        })
        .orderBy('current_sequence', 'desc')
        .limit(1)
        .get();

      const currentSequence = result.data.length > 0
        ? result.data[0].current_sequence
        : 0;

      const newSequence = currentSequence + 1;

      // 更新序列号记录
      await db.collection('order_sequences').add({
        data: {
          date_prefix: datePrefix,
          current_sequence: newSequence,
          created_time: new Date()
        }
      });

      // 缓存序列号
      this.sequenceCache.set(datePrefix, newSequence);

      return newSequence;

    } catch (error) {
      console.error('获取序列号失败:', error);
      // 使用随机数作为备选方案
      return Math.floor(Math.random() * 9000) + 1000;
    }
  }

  /**
   * 生成用户哈希
   * 基于用户openid生成定长哈希
   */
  generateUserHash(openid) {
    const hash = crypto.createHash('sha256')
      .update(openid)
      .digest('hex');

    return hash.substring(0, 6).toUpperCase();
  }

  /**
   * 生成校验码
   */
  generateCheckDigit(...parts) {
    const combined = parts.join('');
    const hash = crypto.createHash('md5').update(combined).digest('hex');
    return hash.substring(0, 2).toUpperCase();
  }

  /**
   * 备用订单号生成
   */
  generateFallbackOrderNumber(openid) {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 8);
    const userHash = this.generateUserHash(openid);

    return `FB${timestamp}${userHash}${random}`.toUpperCase();
  }
}

// 全局订单号生成器实例
const orderNumberGenerator = new OrderNumberGenerator();
```

## 6. 错误处理和重试机制

### 6.1 分层错误处理策略

```javascript
/**
 * 分层错误处理器
 */
class PaymentErrorHandler {
  constructor() {
    this.errorCategories = {
      NETWORK_ERROR: { maxRetries: 3, backoffMs: 1000 },
      BUSINESS_ERROR: { maxRetries: 1, backoffMs: 0 },
      SYSTEM_ERROR: { maxRetries: 2, backoffMs: 2000 },
      VALIDATION_ERROR: { maxRetries: 0, backoffMs: 0 }
    };
  }

  /**
   * 处理支付相关错误
   * @param {Error} error - 错误对象
   * @param {Object} context - 错误上下文
   * @returns {Object} 错误处理结果
   */
  async handleError(error, context = {}) {
    const errorCategory = this.categorizeError(error);
    const errorConfig = this.errorCategories[errorCategory];

    try {
      // 1. 记录错误日志
      await this.logError(error, context, errorCategory);

      // 2. 根据错误类型决定处理策略
      switch (errorCategory) {
        case 'NETWORK_ERROR':
          return await this.handleNetworkError(error, context, errorConfig);

        case 'BUSINESS_ERROR':
          return await this.handleBusinessError(error, context, errorConfig);

        case 'SYSTEM_ERROR':
          return await this.handleSystemError(error, context, errorConfig);

        case 'VALIDATION_ERROR':
          return await this.handleValidationError(error, context, errorConfig);

        default:
          return await this.handleUnknownError(error, context);
      }

    } catch (handlingError) {
      console.error('错误处理本身失败:', handlingError);
      return {
        shouldRetry: false,
        shouldNotify: true,
        severity: 'high',
        handlingResult: 'error_handling_failed'
      };
    }
  }

  /**
   * 错误分类
   */
  categorizeError(error) {
    if (error.name === 'NETWORK_ERROR' || error.code === 'NETWORK_ERROR') {
      return 'NETWORK_ERROR';
    }

    if (error.code && error.code.startsWith('BIZ_')) {
      return 'BUSINESS_ERROR';
    }

    if (error.code && error.code.startsWith('SYS_')) {
      return 'SYSTEM_ERROR';
    }

    if (error.code && error.code.startsWith('VAL_')) {
      return 'VALIDATION_ERROR';
    }

    return 'UNKNOWN_ERROR';
  }

  /**
   * 处理网络错误
   */
  async handleNetworkError(error, context, config) {
    const { retryCount = 0 } = context;

    if (retryCount < config.maxRetries) {
      // 可以重试
      const delayMs = config.backoffMs * Math.pow(2, retryCount);

      return {
        shouldRetry: true,
        delayMs,
        severity: 'medium',
        handlingResult: 'scheduled_for_retry'
      };
    }

    // 超过重试次数，通知人工处理
    await this.notifyManualIntervention(error, context, 'network_error_max_retries');

    return {
      shouldRetry: false,
      shouldNotify: true,
      severity: 'high',
      handlingResult: 'manual_intervention_required'
    };
  }

  /**
   * 处理业务错误
   */
  async handleBusinessError(error, context, config) {
    // 业务错误通常不应重试，而是需要业务层面处理
    const businessActions = await this.determineBusinessAction(error, context);

    switch (businessActions.action) {
      case 'COMPENSATE_USER':
        await this.initiateUserCompensation(context);
        break;

      case 'REFUND_PAYMENT':
        await this.initiateRefund(context);
        break;

      case 'CONTACT_MERCHANT':
        await this.notifyMerchantSupport(error, context);
        break;

      default:
        break;
    }

    return {
      shouldRetry: false,
      shouldNotify: true,
      severity: businessActions.severity || 'medium',
      handlingResult: businessActions.action,
      businessActions
    };
  }

  /**
   * 确定业务处理动作
   */
  async determineBusinessAction(error, context) {
    const errorCode = error.code;

    // 定义错误码和处理动作的映射
    const actionMap = {
      'BIZ_INSUFFICIENT_INVENTORY': {
        action: 'COMPENSATE_USER',
        severity: 'medium',
        message: '库存不足，自动退款'
      },
      'BIZ_PRICE_MISMATCH': {
        action: 'CONTACT_MERCHANT',
        severity: 'high',
        message: '价格异常，需要人工处理'
      },
      'BIZ_ORDER_EXPIRED': {
        action: 'REFUND_PAYMENT',
        severity: 'low',
        message: '订单已过期，自动退款'
      }
    };

    return actionMap[errorCode] || {
      action: 'DEFAULT',
      severity: 'medium',
      message: '未知业务错误'
    };
  }

  /**
   * 记录错误日志
   */
  async logError(error, context, category) {
    const errorLog = {
      error_id: this.generateErrorId(),
      error_category: category,
      error_code: error.code,
      error_message: error.message,
      error_stack: error.stack,
      context: context,
      timestamp: new Date(),
      severity: this.determineSeverity(category)
    };

    await db.collection('error_logs').add({
      data: errorLog
    });

    console.error(`[${category}] ${error.message}`, context);
  }

  generateErrorId() {
    return `ERR_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
  }

  determineSeverity(category) {
    const severityMap = {
      'NETWORK_ERROR': 'medium',
      'BUSINESS_ERROR': 'high',
      'SYSTEM_ERROR': 'high',
      'VALIDATION_ERROR': 'low'
    };

    return severityMap[category] || 'medium';
  }
}

// 全局错误处理器实例
const paymentErrorHandler = new PaymentErrorHandler();
```

### 6.2 智能重试机制

```javascript
/**
 * 智能重试管理器
 */
class SmartRetryManager {
  constructor() {
    this.retryStrategies = new Map();
    this.setupDefaultStrategies();
  }

  /**
   * 设置默认重试策略
   */
  setupDefaultStrategies() {
    // 微信支付API重试策略
    this.retryStrategies.set('wx_payment_api', {
      maxRetries: 3,
      baseDelayMs: 1000,
      maxDelayMs: 30000,
      backoffFactor: 2,
      jitterFactor: 0.1
    });

    // 数据库操作重试策略
    this.retryStrategies.set('database_operation', {
      maxRetries: 2,
      baseDelayMs: 500,
      maxDelayMs: 5000,
      backoffFactor: 1.5,
      jitterFactor: 0.2
    });

    // 业务处理重试策略
    this.retryStrategies.set('business_process', {
      maxRetries: 1,
      baseDelayMs: 2000,
      maxDelayMs: 10000,
      backoffFactor: 1,
      jitterFactor: 0.3
    });
  }

  /**
   * 执行带重试的操作
   * @param {string} strategyKey - 重试策略key
   * @param {Function} operation - 要执行的操作
   * @param {Object} context - 操作上下文
   * @returns {Object} 执行结果
   */
  async executeWithRetry(strategyKey, operation, context = {}) {
    const strategy = this.retryStrategies.get(strategyKey);
    if (!strategy) {
      throw new Error(`未知的重试策略: ${strategyKey}`);
    }

    let lastError = null;
    const executionId = this.generateExecutionId();

    for (let attempt = 1; attempt <= strategy.maxRetries + 1; attempt++) {
      try {
        console.log(`执行操作 [${strategyKey}] attempt ${attempt}/${strategy.maxRetries + 1}, executionId: ${executionId}`);

        const startTime = Date.now();
        const result = await operation();
        const duration = Date.now() - startTime;

        // 记录成功执行
        await this.recordExecution(executionId, strategyKey, attempt, result, duration, null);

        console.log(`操作执行成功 [${strategyKey}] attempt ${attempt}, duration: ${duration}ms`);
        return result;

      } catch (error) {
        lastError = error;

        // 记录失败执行
        await this.recordExecution(executionId, strategyKey, attempt, null, null, error);

        console.error(`操作执行失败 [${strategyKey}] attempt ${attempt}:`, error.message);

        // 判断是否应该重试
        if (attempt > strategy.maxRetries || !this.shouldRetry(error, context)) {
          break;
        }

        // 计算延迟时间
        const delayMs = this.calculateDelay(attempt - 1, strategy);
        console.log(`等待 ${delayMs}ms 后重试 [${strategyKey}]...`);

        await this.sleep(delayMs);
      }
    }

    // 所有重试都失败
    console.error(`操作最终失败 [${strategyKey}], executionId: ${executionId}`, lastError);
    throw lastError;
  }

  /**
   * 计算重试延迟
   */
  calculateDelay(attempt, strategy) {
    // 指数退避 + 随机抖动
    const exponentialDelay = strategy.baseDelayMs * Math.pow(strategy.backoffFactor, attempt);
    const jitter = exponentialDelay * strategy.jitterFactor * (Math.random() - 0.5);
    const totalDelay = Math.min(exponentialDelay + jitter, strategy.maxDelayMs);

    return Math.max(totalDelay, 0); // 确保延迟不为负数
  }

  /**
   * 判断是否应该重试
   */
  shouldRetry(error, context) {
    // 不可重试的错误类型
    const nonRetryableErrors = [
      'VALIDATION_ERROR',
      'PERMISSION_DENIED',
      'RESOURCE_NOT_FOUND',
      'CONFLICT'
    ];

    if (nonRetryableErrors.includes(error.code)) {
      return false;
    }

    // 可重试的错误类型
    const retryableErrors = [
      'NETWORK_ERROR',
      'TIMEOUT',
      'TEMPORARY_FAILURE',
      'SYSTEM_OVERLOADED'
    ];

    return retryableErrors.includes(error.code) ||
           error.message.includes('timeout') ||
           error.message.includes('network');
  }

  /**
   * 记录执行结果
   */
  async recordExecution(executionId, strategyKey, attempt, result, duration, error) {
    const executionLog = {
      execution_id: executionId,
      strategy_key: strategyKey,
      attempt_number: attempt,
      timestamp: new Date(),
      success: error === null,
      duration_ms: duration,
      error_message: error ? error.message : null,
      error_code: error ? error.code : null,
      result_summary: result ? JSON.stringify(result).substring(0, 500) : null
    };

    await db.collection('retry_executions').add({
      data: executionLog
    });
  }

  generateExecutionId() {
    return `EXEC_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// 全局重试管理器实例
const smartRetryManager = new SmartRetryManager();
```

## 总结

微信支付云函数中的幂等性处理是确保系统稳定性和数据一致性的关键。通过实施以上最佳实践：

1. **多层幂等性防护**：订单锁、分布式锁、状态检查等
2. **原子性操作**：库存扣减、状态更新的原子性保证
3. **智能重试机制**：基于错误类型的重试策略
4. **完整的错误处理**：分层错误处理和恢复策略
5. **可追溯的订单号**：唯一性保证和可追溯性
6. **监控和日志**：完整的操作记录和审计日志

这些实践可以确保微信支付系统在高并发、网络异常等复杂场景下的稳定运行。